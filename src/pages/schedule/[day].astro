---
import { getEntry, getCollection } from "astro:content";
import Layout from "../../layouts/Layout.astro";
import Break from "../../components/schedule/break.astro";
import Session from "../../components/schedule/session.astro";
import { addMinutes, format, parseISO } from "date-fns";

const timeToNumber = (time: string) => {
  const [hours, minutes] = time.split(":").map(Number);
  return hours * 60 + minutes;
};

const numberToTime = (number: number) => {
  const hours = Math.floor(number / 60);
  const minutes = number % 60;
  return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
};
export const getStaticPaths = async () => {
  const days = await getCollection("days");

  return days.map((day) => {
    return { params: { day: day.id } };
  });
};

const day = await getEntry("days", Astro.params.day);

// make sure to always have `Main Hall A|B|C` as the last rooms
const ROOMS = day.data.rooms.sort((a, b) => {
  if (a === "Main Hall A" || a === "Main Hall B" || a === "Main Hall C") {
    return 1;
  }

  if (b === "Main Hall A" || b === "Main Hall B" || b === "Main Hall C") {
    return -1;
  }

  return a.localeCompare(b);
});

const sessions = day.data.events
  .map((event) => {
    const startTime = parseISO(event.start);
    const start = format(startTime, "HH:mm");

    let duration = event.duration;

    // round to the nearest 5 minutes
    duration = Math.ceil(duration / 5) * 5;

    const end = format(addMinutes(startTime, duration), "HH:mm");

    return {
      ...event,
      start,
      end,
      type: event.event_type,
    };
  })
  .sort((a, b) => {
    return a.start.localeCompare(b.start);
  });

const sessionsByTime: { [key: string]: Array<(typeof sessions)[0]> } = {};

sessions.forEach((session) => {
  if (!sessionsByTime[session.start]) {
    sessionsByTime[session.start] = [];
  }

  sessionsByTime[session.start].push(session);
});

const sessionAndTimes = Object.entries(sessionsByTime);

for (let i = 0; i < sessionAndTimes.length - 1; i++) {
  const [, sessions] = sessionAndTimes[i];
  const [nextTime] = sessionAndTimes[i + 1];

  const endTimes = sessions.map((session) => timeToNumber(session.end));
  const endTime = Math.max(...endTimes);
  const nextStartTime = timeToNumber(nextTime);

  if (nextStartTime !== endTime) {
    const duration = nextStartTime - endTime;

    if (duration === 5) {
      const roomChangeTime = numberToTime(endTime);
      sessionsByTime[roomChangeTime] = [
        {
          title: "Room Change",
          start: roomChangeTime,
          duration: 5,
          end: numberToTime(endTime + 5),
          type: "room-change",
          event_type: "room-change",
          rooms: ROOMS,
        },
      ];
    } else {
      console.warn("Missing room change", endTime, nextStartTime, duration);
    }
  }
}

const slots = Object.entries(sessionsByTime)
  .sort()
  .map(([time, sessions]) => {
    let type: "session" | "break" | "lunch" | "room-change" = "session";

    if (sessions.every((session) => session.type === "break")) {
      type = "break";

      if (sessions[0].title.toLowerCase().includes("lunch")) {
        type = "lunch";
      }
    } else if (sessions.every((session) => session.type === "room-change")) {
      type = "room-change";
    }

    return { start: time, end: sessions[0].end, type: type };
  });

const gridRows = [];

let row = 1;

const timeToRow: { [key: string]: number } = {};

for (let i = 0; i < slots.length; i++) {
  const current = slots[i];
  const next = slots[i + 1];

  const currentTime = timeToNumber(current.start);
  let nextTime;
  if (next) {
    nextTime = timeToNumber(next.start);
  } else {
    nextTime = timeToNumber(current.end);
  }

  const sizeInMinutes = nextTime - currentTime;
  const size = sizeInMinutes / 5;

  let sizeValue = `repeat( ${size}, fit-content(200px))`;

  if (current.type === "break") {
    sizeValue = `repeat(${size}, var(--break))`;
  } else if (current.type === "room-change") {
    sizeValue = `repeat(${size}, var(--room-change))`;
  }

  gridRows.push(sizeValue);

  for (let i = 0; i < size; i++) {
    const time = numberToTime(currentTime + i * 5);
    timeToRow[time] = row;
    row += 1;
  }

  if (!next) {
    timeToRow[numberToTime(nextTime)] = row;
  }
}

type Break = {
  type: "break" | "room-change";
  rooms: string[];
};

type Session = {
  type: "session";
  rooms: string[];
};

const getColStart = ({ type, rooms }: Break | Session) => {
  if (["room-change", "break"].includes(type)) {
    return 1;
  }

  const indexes = rooms.map((room) => ROOMS.indexOf(room));
  return Math.min(...indexes) + 2;
};

const getColEnd = ({ type, rooms }: Break | Session) => {
  if (["room-change", "break"].includes(type)) {
    return -1;
  }

  const indexes = rooms.map((room) => ROOMS.indexOf(room));
  return Math.max(...indexes) + 3;
};
---

<Layout title="Schedule" description="The schedule for the conference">
  <div class="full-bleed">
    <header class="schedule-container">
      <div
        class="schedule"
        style={{
          gridTemplateColumns: `6ch repeat(${ROOMS.length}, minmax(200px, 1fr))`,
        }}
      >
        <div>Time</div>
        {ROOMS.map((room) => <div>{room}</div>)}
      </div>
    </header>

    <div class="schedule-container">
      <div
        class="schedule"
        style={{
          gridTemplateRows: gridRows.join(" "),
          gridTemplateColumns: `6ch repeat(${ROOMS.length}, minmax(200px, 1fr))`,
        }}
      >
        {
          slots.map((slot) => (
            <div class="slot">
              <div
                class="time"
                style={{
                  "--start": timeToRow[slot.start],
                  "--end": timeToRow[slot.end],
                }}
              >
                <h2>{slot.start}</h2>
              </div>

              {sessionsByTime[slot.start].map((session) => {
                const style = {
                  "--start": timeToRow[session.start],
                  "--end": timeToRow[session.end],
                  "--col-start": getColStart(session),
                  "--col-end": getColEnd(session),
                };
                if (
                  session.type === "room-change" ||
                  session.type === "break"
                ) {
                  return (
                    <Break
                      title={session.title}
                      time={session.start}
                      style={style}
                    />
                  );
                }

                return <Session session={session} style={style} />;
              })}
            </div>
          ))
        }

        <div class="h-12"></div>
      </div>
    </div>
  </div>
</Layout>

<style>
  :global(body) {
    overflow-x: hidden;
  }
  .schedule-container {
    overflow-x: auto;
  }

  header {
    position: sticky;
    top: 0;
    background: var(--color-body-background);
    font-weight: bold;

    > div > div {
      padding: 8px;
    }
  }

  .schedule {
    --header-height: 30px;
    --break: 8px;
    --lunch: 8px;
    --minute: 4px;
    --room-change: calc(var(--minute) * 8);
    --5min: calc(var(--minute) * 5);

    display: grid;
    gap: 2px;
  }

  .slot {
    display: contents;
  }

  :global(.session),
  .time,
  .room-change,
  :global(.break) {
    grid-row: var(--start) / var(--end);
    grid-column: var(--col-start) / var(--col-end);
  }

  :global(.session),
  .time,
  :global(.break),
  .room-change,
  header,
  header > div > div {
    outline: 2px solid var(--color-primary);
  }

  .time {
    padding: 8px;
    grid-column: 1 / 2;
    font-weight: bold;
  }

  pre {
    max-height: 400px;
    overflow: auto;
    border: 1px solid var(--color-primary);
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const containers = document.querySelectorAll(".schedule-container");

    function syncScroll(event: any) {
      const other =
        containers[0] === event.target ? containers[1] : containers[0];
      other.scrollTop = event.target.scrollTop;
      other.scrollLeft = event.target.scrollLeft;
    }

    containers.forEach((container) => {
      container.addEventListener("scroll", syncScroll);
    });
  });
</script>
